{
 parserClass="io.github.josehsantos.hack.lang.HackParser"
  parserUtilClass="io.github.josehsantos.hack.lang.parser.HackParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Hack"
  psiImplClassSuffix="Impl"
  psiPackage="io.github.josehsantos.hack.lang.psi"
  psiImplPackage="io.github.josehsantos.hack.lang.psi.impl"

  elementTypeHolderClass="io.github.josehsantos.hack.lang.psi.HackTypes"
  elementTypeClass="io.github.josehsantos.hack.lang.HackTokenType"
  tokenTypeClass="io.github.josehsantos.hack.lang.HackTokenType"
//  extends(".*expr")="expr"
  //extends(".*statement")="statement"

  tokens=[
     T_SEMICOLON = ";"
     T_COLON = ":"
     T_COMMA = ","
     T_DOT = "."
     T_LBRACKET = "["
     T_RBRACKET = "]"
     T_LPAREN = "("
     T_RPAREN = ")"
     T_LBRACE = "{"
     T_RBRACE = "}"
     T_OR = "|"
     T_XOR = "^"
     T_AND = "&"
     T_PLUS = "+"
     T_MINUS = "-"
     T_MUL = "*"
     T_DIV = "/"
     T_EQUAL = "="
     T_MOD = "%"
     T_NEGATE = "!"
     T_NOT = "~"
     T_LESS = "<"
     T_GREATER = ">"
     T_QUEST = "?"
     T_SILENCE = "@"
     T_SINGLE_QUOTE = "'"
     T_DOUBLE_QUOTE = "\""
     T_DOLLAR_SIGN = "$"
     T_ELLIPSIS="..."
     T_BACK='`'
  ]
}

hackFile ::= T_INLINE_HTML? T_OPEN_TAG top_statement_list?

private top_statement_list::= ( statement //Almost
                       | function_declaration_statement //OK
                       | class_declaration_statement //OK
                       | interface_declaration_statement //OK
                       | enum_declaration_statement //OK
                       | trait_declaration_statement //OK
                       | hh_type_alias_declaration_statement
                       | halt_compiler_statement //OK
                       | namespace_declaration_statement //OK
                       | use_declaration_statement //OK
                       | constant_declaration_statement //OK
                       )+

halt_compiler_statement ::= T_HALT_COMPILER '(' ')' ';'  {pin=1}

//Namespaces
namespace_declaration_statement ::= simple_namespace_statement | block_namespace_statement

private simple_namespace_statement ::= T_NAMESPACE namespace_name ';' {pin=1}
private block_namespace_statement ::= T_NAMESPACE namespace_name? '{'  top_statement_list? '}' {pin=1}

constant_declaration_statement ::= constant_declaration ';'

use_declaration_statement::= T_USE (T_FUNCTION | T_CONST)? use_declarations ';'  {pin=1}

identifier ::= T_STRING
        | T_XHP_ATTRIBUTE
        | T_XHP_CATEGORY
        | T_XHP_CHILDREN
        | T_XHP_REQUIRED
        | T_ENUM
        | T_WHERE
        | T_JOIN
        | T_ON
        | T_IN
        | T_EQUALS
        | T_INTO
        | T_LET
        | T_ORDERBY
        | T_ASCENDING
        | T_DESCENDING
        | T_SELECT
        | T_GROUP
        | T_BY
        | T_TRUE
        | T_FALSE

use_declarations::=  use_declaration (',' use_declaration)*

use_declaration::= namespace_name (T_AS identifier)?

namespace_name::= T_NS_SEPARATOR? identifier (T_NS_SEPARATOR identifier)* {pin=2}

namespace_string::= (T_NAMESPACE namespace_name) | namespace_name

namespace_string_typeargs::= ((T_NAMESPACE T_NS_SEPARATOR? namespace_name) | namespace_name) hh_typeargs_opt?

class_namespace_string_typeargs::= ((T_NAMESPACE namespace_name) | namespace_name) hh_typeargs_opt?

constant_assignment::= hh_name_with_type '=' static_expr {pin=2}

constant_declaration::=  T_CONST constant_assignment (',' constant_assignment)*  {pin=1}

inner_statement_list::= inner_statement*


private inner_statement::=  statement
                    | function_declaration_statement
                    | class_declaration_statement
                    | interface_declaration_statement
                    | trait_declaration_statement

private statement::=
                  block_statement
                | if_statement
                | while_statement
                | do_while_statement
                | for_statement
                | switch_statement
                | break_statement
                | continue_statement
                | return_statement
                | yield_statement
                | global_statement
                | echo_statement
                | unset_statement
                | semicolon_statement
                | html_statement
                | foreach_statement
                | declare_statement
                | try_statement
                | throw_statement
                | goto_statement
                | expr_statement
                | static_statement
                | label_statement


semicolon_statement ::= ';'

if_statement::=  new_if_statement |  normal_if_statement
private normal_if_statement ::= T_IF parenthesized_expr statement? elseif_list else_single? {pin=1}
private new_if_statement ::= T_IF parenthesized_expr ':' inner_statement_list new_elseif_list new_else_single? T_ENDIF ';' {pin=3}


while_statement::= T_WHILE parenthesized_expr  while_statement_body {pin=1}


do_while_statement::= T_DO  statement T_WHILE parenthesized_expr ';' {pin=1}

for_statement::= T_FOR '(' expr_list ';' expr_list ';' expr_list ')'  for_statement_body {pin=1}

switch_statement::= T_SWITCH parenthesized_expr  switch_case_list {pin=1}

break_statement::= T_BREAK expr? ';' {pin=1}

continue_statement::= T_CONTINUE expr? ';' {pin=1}

return_statement::= T_RETURN  (expr|query_expr|await_expr)? ';' {pin=1}

yield_statement::= T_YIELD T_BREAK ';' {pin=1}
global_statement::= T_GLOBAL global_var_list ';' {pin=1}
static_statement::= T_STATIC static_var_list ';'{pin=1}
echo_statement::= T_ECHO expr_list ';' {pin=1}
unset_statement::= T_UNSET '(' variable_list ')' ';' {pin=1}

html_statement::= T_CLOSE_TAG T_INLINE_HTML? T_OPEN_TAG?


foreach_statement::= T_FOREACH '(' expr T_AWAIT? T_AS foreach_variable foreach_optional_arg? ')'  foreach_statement_body {pin=1}

declare_statement::=  T_DECLARE '(' declare_list ')' declare_statement_body {pin=1}

try_catch::= T_CATCH '(' fully_qualified_class_name T_VARIABLE ')' '{' inner_statement_list '}' {pin=1}
try_finally ::= T_FINALLY  finally_statement_list {pin=1}

try_statement::= (T_TRY try_statement_list try_catch additional_catches  optional_finally)
        | (T_TRY try_statement_list try_finally) {pin=1}

throw_statement::= T_THROW expr ';'{pin=1}
goto_statement::= T_GOTO identifier ';'{pin=1}

expr_statement::= (expr|yield_expr|yield_assign_expr|yield_list_assign_expr|await_expr|await_assign_expr|await_list_assign_expr|query_assign_expr) ';'


private try_statement_list::= block_statement
private additional_catches::= try_catch*
private finally_statement_list::= block_statement
private optional_finally::= try_finally?

label_statement::= identifier ':'

function_declaration_statement::= user_attributes? method_modifiers? T_FUNCTION '&'? identifier hh_typevar?  '(' parameter_list ')' hh_opt_return_type? function_body {pin=3}


enum_declaration_statement::= user_attributes? T_ENUM identifier  ':' hh_type (T_AS hh_type)? '{' enum_statement_list '}' {pin=2}


class_declaration_statement::= user_attributes? (T_CLASS | T_ABSTRACT T_CLASS | T_FINAL T_CLASS) ((identifier hh_typevar?)
| T_XHP_LABEL)  extends_from? implements_list? class_statement_block {pin=2}
private class_statement_block ::= '{' class_statement_list '}' {pin=1}


interface_declaration_statement::= user_attributes? T_INTERFACE identifier hh_typevar?  interface_extends_list? class_statement_block {pin=2}

trait_declaration_statement::= user_attributes? T_TRAIT identifier hh_typevar?  implements_list? class_statement_block {pin=2}

extends_from::= T_EXTENDS fully_qualified_class_name {pin=1}


implements_list::= T_IMPLEMENTS interface_list {pin=1}


interface_extends_list::= T_EXTENDS interface_list {pin=1}


interface_list::= (fully_qualified_class_name (',' fully_qualified_class_name)*)?


trait_list::= (fully_qualified_class_name (',' fully_qualified_class_name)*)?


foreach_optional_arg::= T_DOUBLE_ARROW foreach_variable {pin=1}


foreach_variable::= ('&'? variable) | foreach_list_assignment

foreach_list_assignment ::= T_LIST '(' assignment_list ')' {pin=1}



for_new_statement       ::=     ':' inner_statement_list T_ENDFOR ';' {pin=1}
foreach_new_statement   ::=     ':' inner_statement_list T_ENDFOREACH ';'{pin=1}
while_new_statement     ::=     ':' inner_statement_list T_ENDWHILE ';'{pin=1}
declare_new_statement   ::=     ':' inner_statement_list T_ENDDECLARE ';'{pin=1}

foreach_statement_body  ::=  foreach_new_statement | statement
for_statement_body      ::=  for_new_statement     | statement
while_statement_body    ::=  while_new_statement   | statement
declare_statement_body  ::=  declare_new_statement | statement


declare_assignment      ::= identifier '=' static_expr {pin=2}
declare_list            ::= (declare_assignment (',' declare_assignment )*)?
switch_new_statement    ::= ':' ';'? case_list T_ENDSWITCH ';' {pin=1}
switch_statement_list   ::= '{' ';'? case_list '}' {pin=1}
switch_case_list        ::= switch_statement_list | switch_new_statement


case_block              ::= T_CASE expr case_separator inner_statement_list {pin=1}
default_case_block      ::= T_DEFAULT case_separator inner_statement_list {pin=1}

case_list               ::= (case_block|default_case_block)*
case_separator          ::= ':' | ';'

elseif_list             ::=  elseif_body*
elseif_body             ::= T_ELSEIF parenthesized_expr statement {pin=1}


new_elseif_list         ::=  new_elseif_body*
new_elseif_body         ::= T_ELSEIF parenthesized_expr ':' inner_statement_list {pin=1}

else_single             ::= T_ELSE statement {pin=1}
new_else_single         ::= T_ELSE ':' inner_statement_list {pin=1}



parameter_item          ::= user_attributes? parameter_modifiers? hh_type? ('&'|"...")? T_VARIABLE ('=' static_expr)?
parameter_list          ::= (parameter_item (',' parameter_item)*  ','?)?


function_call_parameter_list::= (calling_parameter_item (',' calling_parameter_item)* ','?)?

calling_parameter_item  ::= expr | ('&' variable) | ("..." expr) {}

global_var_list         ::=  (global_var (',' global_var)*)?

global_var              ::= T_VARIABLE | ('$' variable) | ('$' '{' expr '}') {pin=1}

static_var_list::= ((T_VARIABLE | static_assignment) (',' (T_VARIABLE|static_assignment))*)?
static_assignment ::= T_VARIABLE '=' static_expr{pin=2}

enum_statement_list ::=  enum_statement*


enum_statement::= enum_constant_declaration ';'

enum_constant_declaration::= hh_name_with_type '=' static_expr {pin=2}

class_statement_list::= class_statement*



//TODO: Inspect that rule later
class_variable_declarations ::= (variable_modifiers|(member_modifier+ hh_type?))  class_variable_declaration

class_statement::= class_variable_declarations ';'
| constant_declaration ';'
| method_function_declaration ';'?
| xhp_attribute_declaration
| xhp_category_declaration
| xhp_children_declaration
| trait_require_declaration
| trait_use_declaration

trait_require_declaration ::= T_REQUIRE (T_EXTENDS|T_IMPLEMENTS) fully_qualified_class_name ';' {pin=1}
xhp_children_declaration ::= T_XHP_CHILDREN xhp_children_stmt ';' {pin=1}
xhp_category_declaration ::= T_XHP_CATEGORY xhp_category_stmt ';' {pin=1}
trait_use_declaration ::= T_USE trait_list (';'| '{' trait_rules? '}') {pin=1}

xhp_attribute_declaration ::= T_XHP_ATTRIBUTE xhp_attribute_stmt ';' {pin=1}
method_function_declaration ::= user_attributes? method_modifiers? T_FUNCTION '&'? identifier hh_typevar?  '(' parameter_list ')' hh_opt_return_type? function_body {extends=function_declaration_statement}


trait_rules::= (trait_precedence_rule |  trait_alias_rule)+

trait_precedence_rule::= class_namespace_string_typeargs T_DOUBLE_COLON identifier T_INSTEADOF trait_list ';'

trait_alias_rule::= trait_alias_rule_method T_AS method_modifiers? identifier ';'
| trait_alias_rule_method T_AS member_modifier+ ';'

trait_alias_rule_method::= class_namespace_string_typeargs T_DOUBLE_COLON identifier
| identifier

xhp_attribute_stmt::= xhp_attribute_decl (',' xhp_attribute_decl)*

xhp_attribute_decl::= xhp_attribute_decl_type xhp_label_ws xhp_attribute_default? xhp_attribute_is_required?
| T_XHP_LABEL

xhp_attribute_decl_type::= T_ARRAY
| fully_qualified_class_name
| T_VAR
| T_ENUM '{' xhp_attribute_enum? '}'
| T_CALLABLE

xhp_attribute_enum::= literal_expr (',' literal_expr)*

xhp_attribute_default::= '=' static_expr {pin=1}


xhp_attribute_is_required::= '@' T_XHP_REQUIRED


xhp_category_stmt::= T_XHP_CATEGORY_LABEL (',' T_XHP_CATEGORY_LABEL)*

xhp_children_stmt::= xhp_children_paren_expr
| identifier
| T_EMPTY

xhp_children_paren_expr::= '(' xhp_children_decl_expr ')' ('*'|'?'|'+')? {pin=1}

xhp_children_decl_expr::= (xhp_children_paren_expr | xhp_children_decl_tag) ((','|'|') (xhp_children_paren_expr | xhp_children_decl_tag))*

xhp_children_decl_tag::= (identifier
                            | T_XHP_LABEL
                            | T_XHP_CATEGORY_LABEL) ('*'|'?'|'+')?

function_body::= ';' | block_statement
block_statement ::= '{' inner_statement_list '}' {pin=1}


variable_modifiers::= member_modifier+ | T_VAR

method_modifiers::= member_modifier+


member_modifier::= T_PUBLIC
                    | T_PROTECTED
                    | T_PRIVATE
                    | T_STATIC
                    | T_ABSTRACT
                    | T_FINAL
                    | T_ASYNC

private parameter_modifiers::= parameter_modifier+


parameter_modifier::= T_PUBLIC
                        | T_PROTECTED
                        | T_PRIVATE

class_variable_declaration::=  (T_VARIABLE | static_assignment) (','  (T_VARIABLE | static_assignment))*

expr_list::= (expr (',' expr)*)?


yield_expr::= T_YIELD expr (T_DOUBLE_ARROW expr)? {pin=1}

yield_assign_expr::= variable '=' yield_expr {pin=2}

yield_list_assign_expr::= T_LIST '(' assignment_list ')' '=' yield_expr {pin=1}

await_expr::= T_AWAIT expr {pin=1}

await_assign_expr::= variable '=' await_expr {pin=2}

await_list_assign_expr::= T_LIST '(' assignment_list ')' '=' await_expr {pin=1}


private expr_with_parens::= especial_parenthesised_expr
                            | new_expr
                            | clone_expr
                            | xhp_expr
                            | collection_literal_expr

especial_parenthesised_expr ::= '(' expr_with_parens ')'{pin=2}

collection_literal_expr ::= collection_literal
xhp_expr ::= xhp_tag
clone_expr ::= T_CLONE expr {pin=1}
new_expr ::= T_NEW class_name_reference ctor_arguments {pin=1}




private assignment_operator ::= ('=' ('&' T_NEW)?) | T_PLUS_EQUAL | T_MINUS_EQUAL | T_MUL_EQUAL | T_DIV_EQUAL | T_CONCAT_EQUAL | T_MOD_EQUAL | T_AND_EQUAL | T_OR_EQUAL | T_XOR_EQUAL | T_SL_EQUAL | T_SR_EQUAL | T_POW_EQUAL

private expr::= assignment_expr_wrapper

private primary_expr::=
                          dim_expr
                        | lambda_expr
                        | expr_with_parens
                        | parenthesized_expr
                        | variable
                        | scalar_expr
                        | array_literal_expr
                        | shape_literal_expr
                        | map_array_literal_expr
                        | varray_literal_expr
                        | backticks_expr
                        | closure_expr
                        | internal_functions


left assignment_expr ::= assignment_operator ternary_expr_wrapper{pin=1}
left ternary_expr::= '?' expr? ':' ternary_expr_wrapper{pin=1}
left logical_expr::= logical_operator comparative_expr_wrapper{pin=1}
left comparative_expr::= comparative_operator bitwise_expr_wrapper{pin=1}
left bitwise_expr::= bitwise_operator shift_expr_wrapper{pin=1}
left shift_expr::= shift_operator additive_or_concatenation_expr_wrapper{pin=1}
left additive_or_concatenation_expr::= additive_or_concatenation_operator multiplicative_expr_wrapper{pin=1}
left multiplicative_expr::= multiplicative_operator instanceof_expr_wrapper{pin=1}
left instanceof_expr::= T_INSTANCEOF class_name_reference{pin=1}
prefix_expr::=prefix_operator prefix_expr_wrapper {pin=1}
private prefix_expr_wrapper::= prefix_expr  | primary_expr
cast_expr::=   cast_operator  prefix_expr_wrapper{pin=1}
cast_operator ::= T_INT_CAST | T_DOUBLE_CAST | T_STRING_CAST | T_ARRAY_CAST | T_OBJECT_CAST | T_BOOL_CAST | T_UNSET_CAST

//instaceof operator


private assignment_or_list_expr::= assignment_expr | list_assignment_expr
private assignment_expr_wrapper::= ternary_expr_wrapper assignment_or_list_expr*
private ternary_expr_wrapper::= logical_expr_wrapper ternary_expr?
private logical_expr_wrapper::= comparative_expr_wrapper logical_expr*
private comparative_expr_wrapper::= bitwise_expr_wrapper comparative_expr*
private bitwise_expr_wrapper::= shift_expr_wrapper bitwise_expr*
private shift_expr_wrapper::= additive_or_concatenation_expr_wrapper shift_expr*
private additive_or_concatenation_expr_wrapper::= multiplicative_expr_wrapper additive_or_concatenation_expr*
private multiplicative_expr_wrapper::= instanceof_expr_wrapper multiplicative_expr*
private instanceof_expr_wrapper::= cast_expr_wrapper instanceof_expr*
private cast_expr_wrapper::= cast_expr+|prefix_expr_wrapper
prefix_operator::= '@' | '!' | '~' | '+' | '-' | T_INC | T_DEC

print_expr ::= T_PRINT expr {pin=1}
parenthesized_expr ::= '(' expr ')' {pin=1}

list_assignment_expr ::= T_LIST '(' assignment_list ')' '=' expr {pin=1}

lambda_use_vars             ::= T_USE '(' lexical_var_list ')' {pin=1}
closure_expr                ::= member_modifier* T_FUNCTION '&'? '('  parameter_list ')' hh_opt_return_type? lambda_use_vars? '{' inner_statement_list '}'
lambda_expr                 ::= T_ASYNC? (T_VARIABLE|(T_LAMBDA_OP  parameter_list T_LAMBDA_CP hh_opt_return_type?)) lambda_body
lambda_body                 ::= T_LAMBDA_ARROW (expr | await_expr | (block_statement)) {pin=1}
shape_keyname               ::= T_CONSTANT_ENCAPSED_STRING | class_constant

shape_pair                  ::= shape_keyname T_DOUBLE_ARROW expr {pin=2}
shape_pair_static           ::= shape_keyname T_DOUBLE_ARROW static_expr {pin=2}
shape_pair_list             ::= (shape_pair (',' shape_pair)* ','?)?
static_shape_pair_list      ::= (shape_pair_static (',' shape_pair_static)* ','?)?
array_pair_list             ::= (array_pair_item (',' array_pair_item)* ','?)?
shape_literal_expr          ::= T_SHAPE '(' shape_pair_list ')' {pin=2}
array_literal_expr          ::= array_literal_base | short_array_literal_base

private short_array_literal_base    ::= '[' array_pair_list ']' {pin=1}
private array_literal_base          ::= T_ARRAY '(' array_pair_list ')' {pin=1}

private collection_literal          ::= fully_qualified_class_name '{' array_pair_list '}'{pin=2}
map_array_literal_expr      ::= (T_MIARRAY|T_MSARRAY) '(' array_pair_list ')' {pin=1}
varray_literal_expr         ::= T_VARRAY '(' array_pair_list ')' {pin=1}

static_map_array_literal    ::= (T_MIARRAY|T_MSARRAY) '(' static_array_pair_list ')' {pin=1}
static_varray_literal       ::= T_VARRAY '(' static_array_pair_list ')' {pin=1}

static_collection_literal::= fully_qualified_class_name '{' static_array_pair_list '}' {pin=2}

//TODO: Check this private or not
dim_expr                    ::= dim_expr_base array_offset_access (array_offset_access)*
array_offset_access         ::= '[' expr ']'
dim_expr_base               ::= array_literal_expr | class_constant | T_CONSTANT_ENCAPSED_STRING | parenthesized_expr
query_expr                  ::= query_head query_body
query_assign_expr           ::= variable '=' query_expr {pin=2}

query_head::= T_FROM T_VARIABLE T_IN expr
query_body::= query_body_clauses? select_or_group_clause query_continuation?
query_body_clauses::= query_body_clause+
query_body_clause::= from_clause | let_clause | where_clause | join_clause | join_into_clause | orderby_clause

from_clause::= T_FROM T_VARIABLE T_IN expr

let_clause::= T_LET T_VARIABLE '=' expr

where_clause::= T_WHERE expr

join_clause::= T_JOIN T_VARIABLE T_IN expr T_ON expr T_EQUALS expr

join_into_clause::= T_JOIN T_VARIABLE T_IN expr T_ON expr T_EQUALS expr T_INTO T_VARIABLE

orderby_clause::= T_ORDERBY orderings

orderings::= ordering (',' ordering)*

ordering::= expr ordering_direction?

ordering_direction              ::= T_ASCENDING | T_DESCENDING
select_or_group_clause          ::= select_clause | group_clause
select_clause                   ::= T_SELECT expr
group_clause                    ::= T_GROUP expr T_BY expr
query_continuation              ::= T_INTO T_VARIABLE query_body
lexical_var_list                ::= ('&'? T_VARIABLE (',' '&'? T_VARIABLE)* ','?)?
xhp_tag                         ::= T_XHP_TAG_LT T_XHP_LABEL xhp_tag_body T_XHP_TAG_GT

xhp_tag_body::= (xhp_attributes? '/') | (xhp_attributes? T_XHP_TAG_GT xhp_children? T_XHP_TAG_LT '/' xhp_opt_end_label)
xhp_opt_end_label::= T_XHP_LABEL?
xhp_attributes::=  xhp_attribute+
xhp_attribute ::= xhp_attribute_name '=' xhp_attribute_value
xhp_children::=xhp_child+
xhp_attribute_name::= T_XHP_LABEL
xhp_attribute_value::= T_XHP_TEXT | '{' expr '}'
xhp_child::= T_XHP_TEXT | ('{' expr '}') | xhp_tag
xhp_label_ws::= xhp_bareword ((':'|'-') xhp_bareword)*
xhp_bareword::= identifier
                | T_EXIT
                | T_FUNCTION
                | T_CONST
                | T_RETURN
                | T_YIELD
                | T_AWAIT
                | T_TRY
                | T_CATCH
                | T_FINALLY
                | T_THROW
                | T_IF
                | T_ELSEIF
                | T_ENDIF
                | T_ELSE
                | T_WHILE
                | T_ENDWHILE
                | T_DO
                | T_FOR
                | T_ENDFOR
                | T_FOREACH
                | T_ENDFOREACH
                | T_DECLARE
                | T_ENDDECLARE
                | T_INSTANCEOF
                | T_AS
                | T_SWITCH
                | T_ENDSWITCH
                | T_CASE
                | T_DEFAULT
                | T_BREAK
                | T_CONTINUE
                | T_GOTO
                | T_ECHO
                | T_PRINT
                | T_CLASS
                | T_INTERFACE
                | T_EXTENDS
                | T_IMPLEMENTS
                | T_NEW
                | T_CLONE
                | T_VAR
                | T_EVAL
                | T_INCLUDE
                | T_INCLUDE_ONCE
                | T_REQUIRE
                | T_REQUIRE_ONCE
                | T_NAMESPACE
                | T_USE
                | T_GLOBAL
                | T_ISSET
                | T_EMPTY
                | T_HALT_COMPILER
                | T_STATIC
                | T_ABSTRACT
                | T_FINAL
                | T_PRIVATE
                | T_PROTECTED
                | T_PUBLIC
                | T_ASYNC
                | T_UNSET
                | T_LIST
                | T_ARRAY
                | T_LOGICAL_OR
                | T_LOGICAL_AND
                | T_LOGICAL_XOR
                | T_CLASS_C
                | T_FUNC_C
                | T_METHOD_C
                | T_LINE
                | T_FILE
                | T_DIR
                | T_NS_C
                | T_COMPILER_HALT_OFFSET
                | T_TRAIT
                | T_TRAIT_C
                | T_INSTEADOF
                | T_TYPE
                | T_NEWTYPE
                | T_SHAPE

simple_function_call_expr::= namespace_string_typeargs '(' function_call_parameter_list ')' {pin=2}

fully_qualified_class_name::= class_namespace_string_typeargs
                    | T_XHP_LABEL

static_class_name::= fully_qualified_class_name
                    | T_STATIC
                    | reference_variable

class_name_reference::=   fully_qualified_class_name
                        | T_STATIC
                        | variable_no_calls

exit_expr::= T_EXIT (('(' ')' ) | parenthesized_expr)


backticks_expr::= '`' (T_ENCAPSED_AND_WHITESPACE | encaps_list)* '`'

ctor_arguments::= '(' function_call_parameter_list  ')'


literal_expr::=   T_LNUMBER
                | T_DNUMBER
                | T_ONUMBER
                | T_CONSTANT_ENCAPSED_STRING
                | T_LINE
                | T_FILE
                | T_DIR
                | T_CLASS_C
                | T_TRAIT_C
                | T_METHOD_C
                | T_FUNC_C
                | T_NS_C
                | T_COMPILER_HALT_OFFSET
                | T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE T_END_HEREDOC
                | T_START_HEREDOC T_END_HEREDOC



 private static_primary_expr ::=   literal_expr
                    | namespace_string
                    | static_array_expr
                    | static_shape_expr
                    | static_class_constant
                    | static_collection_literal
                    | static_map_array_literal
                    | static_varray_literal
                    | static_parenthesized_expr

static_expr::= static_ternary_expr_wrapper

left static_ternary_expr::= '?' static_expr? ':' static_ternary_expr_wrapper
left static_logical_expr::= logical_operator static_comparative_expr_wrapper
left static_comparative_expr::= comparative_operator static_bitwise_expr_wrapper
left static_bitwise_expr::= bitwise_operator static_shift_expr_wrapper
left static_shift_expr::= shift_operator static_additive_or_concatenation_expr_wrapper
left static_additive_or_concatenation_expr::= additive_or_concatenation_operator static_multiplicative_expr_wrapper
left static_multiplicative_expr::= multiplicative_operator static_prefix_expr
static_prefix_expr::= (static_prefix_operator static_prefix_expr) | static_primary_expr

private static_ternary_expr_wrapper::= static_logical_expr_wrapper static_ternary_expr?
private static_logical_expr_wrapper::= static_comparative_expr_wrapper static_logical_expr*
private static_comparative_expr_wrapper::= static_bitwise_expr_wrapper static_comparative_expr*
private static_bitwise_expr_wrapper::= static_shift_expr_wrapper static_bitwise_expr*
private static_shift_expr_wrapper::= static_additive_or_concatenation_expr_wrapper static_shift_expr*
private static_additive_or_concatenation_expr_wrapper::= static_multiplicative_expr_wrapper static_additive_or_concatenation_expr*
private static_multiplicative_expr_wrapper::= static_prefix_expr static_multiplicative_expr*

comparative_operator::=    T_IS_IDENTICAL | T_IS_NOT_IDENTICAL | T_IS_EQUAL | T_IS_NOT_EQUAL | '<' | T_IS_SMALLER_OR_EQUAL | '>' | T_IS_GREATER_OR_EQUAL
bitwise_operator ::= '|' | '&' | '^'
logical_operator ::= T_BOOLEAN_OR | T_BOOLEAN_AND | T_LOGICAL_OR | T_LOGICAL_AND | T_LOGICAL_XOR
shift_operator::= T_SL | T_SR
additive_or_concatenation_operator::= '+'|'-'|'.'
multiplicative_operator::= '*' | '/' | '%' | T_POW
static_prefix_operator::= '!' | '~' | '+' | '-'


static_parenthesized_expr ::= '(' static_expr ')' {pin=1}
static_shape_expr ::= T_SHAPE '(' static_shape_pair_list ')'{pin=2}
static_array_expr ::= (T_ARRAY '(' static_array_pair_list ')')  | ('[' static_array_pair_list ']')

static_class_constant::= class_namespace_string_typeargs T_DOUBLE_COLON identifier
| T_XHP_LABEL T_DOUBLE_COLON identifier
| class_namespace_string_typeargs T_DOUBLE_COLON T_CLASS

scalar_expr::=
               class_constant
            |  namespace_string
            | T_STRING_VARNAME
            | literal_expr
            | double_quotes_string
            | single_quotes_string
            | here_doc_string

private here_doc_string ::= T_START_HEREDOC encaps_list T_END_HEREDOC
private single_quotes_string ::= "'" encaps_list "'"
private double_quotes_string ::= '"' encaps_list '"'

static_array_pair_list::= (static_array_item (',' static_array_item)* ','? ','?)?
static_array_item ::= static_expr (T_DOUBLE_ARROW static_expr)?

literal_scalar_ae::= T_LNUMBER
| T_DNUMBER
| T_ONUMBER
| T_CONSTANT_ENCAPSED_STRING
| T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE T_END_HEREDOC
| T_START_HEREDOC T_END_HEREDOC

static_numeric_scalar_ae::= ('+'|'-')?( T_LNUMBER
| T_DNUMBER
| T_ONUMBER
| identifier
)

static_scalar_ae::= literal_scalar_ae
| identifier
| static_numeric_scalar_ae
| T_ARRAY '(' static_array_pair_list_ae ')'
| '[' static_array_pair_list_ae ']'
| T_SHAPE '(' static_shape_pair_list_ae ')'

static_array_pair_list_ae::= (static_array_item_ae (',' static_array_item_ae)* ','?)?


static_array_item_ae ::= static_scalar_ae (T_DOUBLE_ARROW static_scalar_ae)?

static_shape_pair_list_ae::= (static_shape_pair_item (',' static_shape_pair_item)* ','?)?


static_shape_pair_item ::= shape_keyname T_DOUBLE_ARROW static_scalar_ae

static_scalar_list_ae::= (static_scalar_ae (',' static_scalar_ae)* ','?)?

attribute_static_scalar_list::= '(' static_scalar_list_ae ')'

user_attribute ::= identifier attribute_static_scalar_list?

user_attribute_list::=  (user_attribute (',' user_attribute)* ','?)?

user_attributes::= T_SL user_attribute_list T_SR

private property_access::= property_access_without_variables | property_access_variable
private property_access_variable ::=  variable_without_objects_expr {pin=1}
private property_access_without_variables::=  (identifier|'{' expr '}') {pin=1}

dimmable_variable_access_expr::=  array_access+ | ('(' expr_with_parens ')' array_access)

array_access::=  (array_offset_access | '{' expr '}')

dimmable_variable_no_calls_access::= array_access+ |('(' expr_with_parens ')' array_access+)

private possible_variable::= (
                                   simple_function_call_expr
                                 | callable_function_call_expr
                                 | class_method_call_expr
                                 | dimmable_variable_access_expr
                                 | static_class_variable_expr
                                 | variable_without_objects_expr
                                 | parenthesized_variable_expr
                                 )

private parenthesized_variable_expr ::= '(' variable ')'

private member_variable_wrapper::=  (especial_parenthesised_expr|possible_variable) (method_call_expr|member_variable_expr)*

left member_variable_expr ::= T_OBJECT_OPERATOR property_access
left method_call_expr::= T_OBJECT_OPERATOR ((identifier hh_typeargs_opt?)|variable_without_objects_expr|('{' expr '}'))
                                                                                   '(' function_call_parameter_list ')' {pin=3}

private variable::=  member_variable_wrapper

static_class_variable_expr ::= static_class_name T_DOUBLE_COLON variable_without_objects_expr
callable_function_call_expr ::= callable_variable '(' function_call_parameter_list ')'

callable_variable::= variable_without_objects_expr | dimmable_variable_access_expr | parenthesized_variable_expr


class_method_call_expr::= static_class_name T_DOUBLE_COLON ((identifier hh_typeargs_opt?)|variable_without_objects_expr|('{' expr '}')) '(' function_call_parameter_list ')'

variable_without_objects_expr::= '$'* reference_variable

reference_variable::= compound_variable ((array_offset_access)|('{' expr '}')|compound_variable)*
compound_variable::= T_VARIABLE | ('$' '{' expr '}')


//private variable_no_calls::= variable_without_objects_expr
//                    | dimmable_variable_no_calls_access
//                    | variable_no_calls property_access
//                    | '(' expr_with_parens ')' property_access
//                    | static_class_name T_DOUBLE_COLON variable_without_objects_expr
//                    | '(' variable ')'


//dimmable_variable_no_calls::= ((variable_no_calls |('(' expr_with_parens')') ) property_access_without_variables) | '(' variable ')'

assignment_list::= ((variable | (T_LIST '(' assignment_list ')')) (',' (variable | (T_LIST '(' assignment_list ')')))*)?

array_pair_item::=  expr (T_DOUBLE_ARROW (expr|(&variable)))?

encaps_list::=(T_ENCAPSED_AND_WHITESPACE|encaps_var)*

encaps_var::= T_VARIABLE
| T_VARIABLE '[' encaps_var_offset ']'
| T_VARIABLE T_OBJECT_OPERATOR identifier
| T_DOLLAR_OPEN_CURLY_BRACES expr '}'
| T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME array_offset_access '}'
| T_CURLY_OPEN variable '}'

encaps_var_offset::= identifier | T_NUM_STRING | T_VARIABLE

private internal_functions::=     internal_isset_expr
                                | internal_empty_expr
                                | internal_include_expr
                                | internal_eval_expr
                                | internal_require_expr
                                | internal_tuple_expr
                                | exit_expr
                                | print_expr



internal_tuple_expr ::= T_TUPLE '(' function_call_parameter_list ')' {pin=1}
internal_require_expr ::= (T_REQUIRE|T_REQUIRE_ONCE) expr {pin=1}
internal_eval_expr ::= T_EVAL '(' expr ')' {pin=1}
internal_include_expr ::= (T_INCLUDE|T_INCLUDE_ONCE) expr {pin=1}
internal_empty_expr ::= T_EMPTY '(' expr ')' {pin=1}
internal_isset_expr ::= T_ISSET '(' variable_list ')' {pin=1}

variable_list::= (variable (',' variable)*)?

class_constant::= static_class_name T_DOUBLE_COLON (identifier|T_CLASS)

private hh_type_alias_declaration_statement::= hh_type_declaration_statement | hh_new_type_declaration_statement

hh_new_type_declaration_statement ::= T_NEWTYPE identifier hh_typevar? (T_AS hh_type)? '=' hh_type ';' {pin=1}
hh_type_declaration_statement ::= T_TYPE identifier hh_typevar? '=' hh_type ';' {pin=1}

private hh_name_with_type::= hh_type? identifier

hh_typeargs_opt::= T_TYPELIST_LT hh_type_list T_TYPELIST_GT {pin=1}

hh_type_list::= (hh_type (',' hh_type)* ','?)?

hh_func_type_list::= hh_type_list "..."?

hh_opt_return_type::= ':' hh_type {pin=1}

hh_typevar::=T_TYPELIST_LT hh_typevar_list T_TYPELIST_GT {pin=1}
hh_typevar_item::= hh_typevar_variance? identifier (T_AS hh_type)?
hh_typevar_list::= (hh_typevar_item (',' hh_typevar_item)?)?
hh_typevar_variance::= '+' | '-'


hh_shape_member_type::= T_CONSTANT_ENCAPSED_STRING T_DOUBLE_ARROW hh_type
| class_namespace_string_typeargs T_DOUBLE_COLON identifier T_DOUBLE_ARROW hh_type

hh_shape_member_list::= (hh_shape_member_type (',' hh_shape_member_type)* ','?)?

private hh_type::= hh_nullable_type
        | hh_soft_type
        | ident_type
        | array_type
        | callable_type
        | hh_shape_type
        | hh_xhp_type
        | hh_function_type
        | hh_tuple_type


 hh_shape_type::= T_SHAPE '(' hh_shape_member_list ')' {pin=1}
 hh_tuple_type ::= '(' hh_type ',' hh_type (',' hh_type)* ','? ')' {pin=1}
 hh_function_type ::= '(' T_FUNCTION '(' hh_func_type_list ')' ':' hh_type ')' {pin=2}
 hh_xhp_type ::= T_XHP_LABEL
 callable_type ::= T_CALLABLE
 array_type ::= T_ARRAY hh_typeargs_opt?
 ident_type ::= class_namespace_string_typeargs
 hh_nullable_type ::= '?' hh_type {pin=1}
 hh_soft_type ::= '@' hh_type {pin=1}

